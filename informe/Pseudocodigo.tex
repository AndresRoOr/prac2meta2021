	\section{Pseudocódigo}
	
	
		\begin{algorithm}[H]
			\caption{Algoritmo Genético}
			\begin{algorithmic}
				\STATE $poblacionPadres \leftarrow GeneraPoblacionInicial(semilla)$
				\WHILE{evaluacionesRelizadas$<$evaluacionesLimite}
				\STATE Evaluacion(poblacionPadres)
				\STATE $elites \leftarrow SeleccionElites(poblacionPadres)$
				\STATE $poblacionHijos \leftarrow CruzarPoblacion(poblacionPadres,semilla)$
				\STATE Reparar(poblacionHijos)
				\STATE MutarPoblacion(poblacionHijos,semilla)
				\STATE Evaluacion(poblacionHijos)
				\STATE $poblacionPadres \leftarrow ReemplazarElite(poblacionHijos, elite)$
				\ENDWHILE	
			\end{algorithmic}
		\end{algorithm}
	
	\paragraph{}La primera acción que se realiza en la función principal es la generación de un conjunto de individuos aleatorios que se almacenará en la variable global "poblacionPadres". La función encargada de realizar esta labor es "GeneraPoblacionInicial(semilla)"
	
	\paragraph{}Damos paso a la ejecución de un bucle while hasta que alcancemos el número de evaluaciones objetivo. Este número de evaluaciones lo indica la variable "evaluacionesLimite", parámetro del programa.
	
	\paragraph{}Lo primero que realizamos dentro del bucle while es calcular los costes de todos y cada uno de los individuos pertenecientes a "poblacionPadres". Esta tarea sera encomendada a la función "Evaluacion(poblacionPadre)".
	
	\paragraph{} Cuando ya dispongamos de los costes calculados de todos los individuos de "poblacionPadres", lo siguiente que debemos hacer es guardar en "elites" los individuos élites que nos indique "numElites" (parámetro del programa). La función "SeleccionElites(poblacionPadres)" será la encargada de realizar esta tarea.

	\paragraph{}Procedemos ahora a cruzar "poblacionPadres". "CruzarPoblacion(poblacionPadres,semilla)" es la función que realiza dicha tarea, y la población resultante se guarda en la variable "poblacionHijos".
	
		
	\begin{algorithm}[H]
		\caption{GeneraPoblacionInicial(semilla)}
		\begin{algorithmic}
			\STATE $individuo \leftarrow \emptyset$
			\STATE $poblacion \leftarrow \emptyset$
			\WHILE{tamañoPoblacion$<$numIndividuosPoblacion}
			\WHILE{numGenesIndividuo$<$numGenesIndividuos)}
			\STATE $genAleatorio \leftarrow GeneraEnteroAleatorio(semilla)$
			\IF{$genAleatorio \notin individuo$}
			\STATE $individuo \leftarrow individuo\cup\{genAleatorio\}$
			\ENDIF
			\ENDWHILE
			\STATE $poblacion \leftarrow poblacion\cup\{individuo\}$
			\STATE $individuo \leftarrow \emptyset$
			\ENDWHILE
			\RETURN poblacion
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Inicializamos las variables "individuo" y "poblacion". La variable "individuo" se utilizará como contenedor de todos los genes que se vayan generando aleatoriamente, se inicializa como un conjunto vacío. "poblacion" irá almacenando cada uno de los individuos generados, se inicializa como un conjunto vacío.
	
	\paragraph{}Hasta que "poblacion" no contenga el número de individuos especificado como parámetro del programa hacemos lo siguiente:
	
	\paragraph{}Generamos un genotipo aleatorio haciendo uso de la función "GeneraEnteroAleatorio(semilla)" y lo almacenamos en la variable local "genAleatorio".
	
	\paragraph{}Comprobamos que "genAleatorio" no se encuentre ya contenido dentro de "individuo" y lo añadimos en el caso de que cumpla con esta condición.
	
	\paragraph{}Repetimos la generación aleatoria de genotipos hasta que el número de los mismos contenido en "individuo" se corresponda con el número de genotipos pasado como parámetro del programa.
	
	\paragraph{}Cuando "individuo" tiene el número de genes deseado, se añade a "poblacion" y acto seguido se modifica el valor de "individuo" a vacío para dar paso a la generación de otro "individuo" nuevo.
	
	\paragraph{}Una vez tengamos hayamos completado "poblacion", la devolvemos como resultado de la ejecución de la función.

	\begin{algorithm}[H]
		\caption{Evaluacion(poblacion)}
		\begin{algorithmic}
			\STATE
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{SeleccionElites(poblacion)}
		\begin{algorithmic}
			\STATE $individuosElites \leftarrow \emptyset$
			\STATE $mejor \leftarrow \emptyset$
			\STATE $costeMejor \leftarrow 0$
			\WHILE{individuosElites.tamaño()$<$numElites}
			\FOR{$individuo \in poblacion$ }
			\IF{(individuo.coste$>$costeMejor)$\wedge$($individuo \notin individuosElite$)}
			\STATE $mejor \leftarrow individuo$
			\STATE $costeMejor \leftarrow individuo.coste$
			\ENDIF
			\ENDFOR
			\STATE $individuosElites \leftarrow individuosElites\cup\{mejor\}$
			\ENDWHILE
			\RETURN individuosElites
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}El primer paso de todos es inicializar las variables locales "individuosElites", "mejor" y "costeMejor". "individuosElites" es un vector encargado de ir almacenando los mejores individuos de "población" que se encuentren, se inicializa como un conjunto vacío. "mejor" se utiliza para ir almacenan uno a uno los individuos de "poblacion" que presenten un mejor coste para guardarlos posteriormente en "individuosElites", su valor se inicia como vacío. "costeMejor" guarda el coste del mejor individuo encontrado hasta el momento para poder comparar con el resto de individuos de "poblacion", su valor se inicia a cero.
	
	\paragraph{}El algoritmo de la función realiza un bucle for hasta que el tamaño de "individuosElites" se corresponda con "numElites", es decir, el número de individuos elites que se guardan. El valor de "numElites" se deberá pasar como parámetro del programa.
	
	\paragraph{}El bucle for consiste en recorrer todos los individuos de "poblacion" y, si el coste de "individuo" mejora a "mejorCoste" y no ha sido introducido aún en "individuosElites", se actualizan los valores de "mejor" y "mejorCoste" con los datos del individuo. Cuando se termina el bucle for se introduce el mejor individuo encontrado en esa iteración del bucle while en "individuosElites".
	
	\paragraph{}Una vez que hayamos completado "individuosElites", lo devolvemos como resultado de la ejecución de la función.

	\begin{algorithm}[H]
		\caption{CruzarPoblacion(poblacion,semilla)}
		\begin{algorithmic}
			\STATE $poblacionHijos \leftarrow \emptyset$
			\STATE $poblacionHijos \leftarrow SeleccionaPoblacion(poblacion,semilla)$
			\IF{tipoCruceMPX}
			\STATE $poblacionHijos \leftarrow RealizaCruceMPX(poblacionHijos)$
			\ELSE
			\STATE $poblacionHijos \leftarrow RelizaCruce2p(poblacionHijos)$
			\ENDIF
			\RETURN poblacionHijos
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Se inicializa el valor de "poblacionHijos" a un conjunto vacío para evitar errores.
	
	\paragraph{}A continuación, rellenamos el vector a partir de "poblacion" con la función "SeleccionaPoblacion(poblacion, semilla)".
	
	\paragraph{}Una vez tenemos "poblacionHijos" relleno con todos los individuos necesarios, damos paso a ejecutar el cruce. El tipo de cruce viene determinado por la variable "tipoCruceMPX", un booleano.
	
	\paragraph{}Si el valor de "tipoCruceMPX" resulta positivo, se lanza la ejecución de "RealizaCruceMPX(poblacionHijos)". En caso contrario, se lanza "RealizaCruce2p(poblacionHijos)".
	
	\paragraph{} Una vez se haya realizado la ejecución del cruce, se devuelve "poblacionHijos" como resultado de ejecutar la función.

	\begin{algorithm}[H]
		\caption{SeleccionaPoblacion(poblacion,semilla)}
		\begin{algorithmic}
			\STATE $poblacionHijos \leftarrow \emptyset$
			\WHILE{tamañoPoblacionHijos$<$numHijos}
			\STATE $individuoSeleccionado \leftarrow SeleccionaIndividuo(poblacion,semilla)$
			\STATE $poblacionHijos \leftarrow poblacionHijos\cup\{individuoSeleccionado\}$
			\ENDWHILE
			\RETURN poblacionHijos
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Mientras que el tamaño de "poblacionHijos" sea inferior a "numHijos" (el número de hijos de cada generación) se realizará lo siguiente:
	
	\paragraph{} Se selecciona por torneo binario un individuo perteneciente a "poblacion" haciendo uso de la función "SeleccionaIndividuo(poblacion,semilla)". El individuo que resulte ganador se almacena en la variable "individuoSeleccionado".
	
	\paragraph{}"individuoSeleccionado" se añade a "poblacionHijos" y se repite el proceso.
	
	\paragraph{}Una vez "poblacionHijos" alcanza el tamaño deseado, finaliza la ejecución de la función y se devuelve como resultado.

	\begin{algorithm}[H]
		\caption{SeleccionaIndividuo(poblacion,semilla)}
		\begin{algorithmic}
			\STATE $seleccionado1 \leftarrow GeneraEnteroAleatorio(semilla)$
			\STATE $seleccionado2 \leftarrow GeneraEnteroAleatorio(semilla)$
			\WHILE{seleccionado1==seleccionado2}
			\STATE $seleccionado2 \leftarrow GeneraEnteroAleatorio(semilla)$
			\ENDWHILE
			\IF{poblacion[seleccionado1].coste $>$ poblacion[seleccionado2].coste}
			\RETURN poblacion[seleccionado1]
			\ELSE
			\RETURN poblacion[seleccionado2]
			\ENDIF
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Para realizar el torneo binario lo primero que necesitamos es generar dos números aleatorios que se corresponderan con los índices en los que se encuentran los individuos seleecionados. Realizaremos tal generación de números aleatorios con la función "GeneraEnteroAleatorio(semilla)", y almacenaremos los valores resultantes en las variables "seleccionado1" y "seleccionado2".
	
	\paragraph{}Comprobamos que no se repitan los valores de "seleccionado1" y "seleccionado2". Si ocurre esto, generamos otro nuevo valor para "seleccionado2" hasta que obtengamos uno válido.
	
	\paragraph{}Para finalizar, comparamos el coste de los dos individuos seleccionados y devolvemos como resultado aquel que posea un mejor coste.

	\begin{algorithm}[H]
		\caption{RealizarCruceMPX(poblacionHijos)}
		\begin{algorithmic}
			\STATE
			
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{RealizarCruce2p(poblacionHijos)}
		\begin{algorithmic}
			\FOR{i=0; i$<$49; i+=2}
			\STATE $aleatorioCruce\leftarrow GeneraFloatAleatorio(semilla)$
			\IF{aleatorioCruce$<=$probabilidadCruce}
			\STATE $corte1 \leftarrow GeneraEnteroAleatorio(semilla)$
			\STATE $corte2 \leftarrow GeneraEnteroAleatorio(semilla)$
			\STATE $padre1 \leftarrow poblacionPadre[i]$
			\STATE $padre2 \leftarrow poblacionPadre[i+1]$
			\WHILE{corte1==corte2}
			\STATE $corte2 \leftarrow GeneraEnteroAleatorio(semilla)$
			\ENDWHILE
			\FOR{j=0;j$<$corte1;j++}
			\STATE $hijo1 \leftarrow hijo1\cup padre1.getGen[j]$
			\STATE $hijo2 \leftarrow hijo2\cup padre2.getGen[j]$
			\ENDFOR
			\FOR{j=corte1;j$<$corte2;j++}
			\STATE $hijo1 \leftarrow hijo1\cup padre2.getGen[j]$
			\STATE $hijo2 \leftarrow hijo2\cup padre1.getGen[j]$
			\ENDFOR
			\FOR{j=corte2;j$<$tamañoIndividuo;j++}
			\STATE $hijo1 \leftarrow hijo1\cup padre1.getGen[j]$
			\STATE $hijo2 \leftarrow hijo2\cup padre2.getGen[j]$
			\ENDFOR
			\STATE $poblacionHijos[i] \leftarrow hijo1$
			\STATE $poblacionHijos[i+1] \leftarrow hijo2$
			\ENDIF
			\ENDFOR
			\RETURN poblacionHijos
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Recorremos "poblacion" de dos en dos realizando lo que a continuación se expone.
	
	\paragraph{}Lo primero a realizar es comprobar si debemos realizar el cruce entre los dos primeros padres. Esta comprobación se realiza comparando "aleatorioCruce" y "probabilidadCruce". "aleatorioCruce" almacena un float aleatorio generado haciendo uso de la función "GeneraFloatAleatorio(semilla)"."probabilidadCruce" tiene almacenada la probabilidad de que dos individuos se reproduzcan, esta información se pasa al programa como parámetro.
	
	\paragraph{}En el caso de que sí se tengan que cruzar, generamos dos puntos de corte aleatorios haciendo uso de "GeneraEnteroAleatorio(semilla)" y los almacenamos en las variables "corte1" y "corte2". Almacenamos en las variables "padre1" y "padre2" los individuos a cruzar.
	
	\paragraph{}Comprobamos que los cortes generados no sean los mismos y, si lo son, generamos otro valor aleatorio para "corte2" hasta que los dos cortes dejen de ser iguales.
	
	\paragraph{}Rellenamos "hijo1" con lo genotipos de "padre2" e "hijo2" con los genotipos de "padre1" hasta llegar a "corte1". Rellenamos los genotipos a continuación de "corte1" de "hijo1" con los genotipos de "padre1", y los genotipos de "hijo2" con los de "padre2" hasta llegar a "corte2". A partir de "corte2" y hasta llegar al final, rellenamos "hijo1" con los genotipos de "padre2", e "hijo2" con los genotipos de "padre1".
	
	\paragraph{}Cuando hayamos completado el cruce, sobreescribimos el valor de la posición de "padre1" y "padre2" con el valor de "hijo1" e "hijo2" en "poblacionHijos". 
	
	\paragraph{}Una vez hayamos terminado el bucle for principal, tendremos almacenados en "poblacionHijos" todos los nuevos individuos resultantes del cruce. Devolvemos "poblacionHijos" como resultado.

	\begin{algorithm}[H]
		\caption{Reparar(poblacionHijos)}
		\begin{algorithmic}
			
			\FOR{$individuo \in poblacionHijos$}
			\IF{!FuncionSolucion(individuo)}
			\IF{tamañoIndividuo$>$tamañoIndividuoProblema}
			\WHILE{tamañoIndividuo$>$tamañoIndividuoProblema}
			\STATE $elementoMenor \leftarrow CalcularAportes(individuo)$
			\STATE $individuo \leftarrow individuo\{elementoMenor\}$
			\ENDWHILE
			\ELSIF{tamañoIndividuo$<$tamañoIndividuoProblema}
			\STATE $elementoMayor \leftarrow CalcularMayorAporte(individuo)$
			\STATE $individuo \leftarrow individuo\cup\{elementoMayor\}$
			\ENDIF
			\ENDIF
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{FuncionSolucion(individuo)}
		\begin{algorithmic}
			\FOR {i=0;i$<$numGenesIndividuo-1;i++}
			\FOR {j=i+1;numGenesIndividuo;j++}
			\IF{individuo[i]==individuo[j]}
			\STATE $seRepite \leftarrow true$
			\ENDIF
			\ENDFOR
			\STATE $numGenes \leftarrow numGenes+1$
			\ENDFOR
			\IF{numGenes!=numGenesIndividuo}
			\STATE malTamaño $\leftarrow true$
			\ENDIF
			\RETURN !(malTamaño $\vee$ seRepite)
			
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{CalcularAportes(individuo)}
		\begin{algorithmic}
			\STATE $aporte \leftarrow 0$
			\STATE $listaAportes \leftarrow \emptyset$
			\FOR {gen1 $\in$ individuo}
			\FOR{gen2 $\in$ individuo}
			\STATE $aporte \leftarrow aporte + matrizDistancias[gen1][gen2]$
			\ENDFOR
			\STATE AñadirAporte(gen1,aporte)
			\ENDFOR
			\STATE Sort(listaAportes)
			\RETURN listaAportes[0]
			
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{CalcularMayorAporte(individuo)}
		\begin{algorithmic}
			\STATE $aporte \leftarrow 0$
			\STATE $listaAportes \leftarrow \emptyset$
			\FOR {gen1 $\in$ matrizDatos}
			\FOR{gen2 $\in$ matrizDatos}
			\STATE $aporte \leftarrow aporte + matrizDistancias[gen1][gen2]$
			\ENDFOR
			\STATE AñadirAporte(gen1,aporte)
			\ENDFOR
			\STATE Sort(listaAportes)
			\RETURN listaAportes[numGenesIndividuos-1]
			
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{Mutar(poblacionHijos,semilla)}
		\begin{algorithmic}
			\FOR{$individuo \in poblacionHijos$}
			\STATE $posMuta \leftarrow GeneraEnteroAleatorio(semilla)$
			\STATE $eleMutado \leftarrow GeneraEnteroAleatorio(semilla)$
			\STATE Intercambia(individuo,posMuta,eleMutado)
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{ReemplazarElite(poblacionHijos,elites)}
		\begin{algorithmic}
			\STATE Sort(poblacionHijos)
			\STATE $indice \leftarrow 0$
			\FOR{$elite \in elites$}
			\STATE $poblacionHijos[indice] \leftarrow elite$
			\STATE $indice \leftarrow indice+1$
			\ENDFOR
			\RETURN poblacionHijos
		\end{algorithmic}
	\end{algorithm}
	